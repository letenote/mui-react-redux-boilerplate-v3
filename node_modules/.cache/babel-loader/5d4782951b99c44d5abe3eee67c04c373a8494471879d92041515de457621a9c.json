{"ast":null,"code":"import { createSxResult } from \"../utils/createSxResult\";\nimport { BREAKPOINT_KEYS } from \"../utils/muiBreakpoints\";\nexport class ResponsiveBuilder {\n  constructor(params) {\n    this.config = params.config;\n    this.hidden = params.hidden;\n    this.breakpointKeys = Object.keys(params.config);\n  }\n  isHidden(breakpoint) {\n    if (!this.hidden) return false;\n    if (typeof this.hidden === \"boolean\" && this.hidden) return true;\n    return this.hidden.includes(breakpoint);\n  }\n  /**\n   * use target as base breakpoints, the result will start from the minimum of target\n   *          xs | sm | md | lg | xl\n   *  target     | y  |    |  y |\n   *   this   y  |    | y  |    |\n   *  ===============================\n   *  result     | y  | y  | y  |\n   */\n\n  mergeBreakpoints(target) {\n    var targetFound = false;\n    var result = [];\n    var targetKeys = Array.isArray(target) ? target : Object.keys(target);\n    var thisKeys = Object.keys(this.config);\n    BREAKPOINT_KEYS.forEach(key => {\n      if (targetKeys.includes(key)) {\n        targetFound = true;\n        result.push(key);\n      } else {\n        if (thisKeys.includes(key) && targetFound) {\n          result.push(key);\n        }\n      }\n    });\n    return result;\n  }\n  generateSxWithHidden(options) {\n    var {\n      config,\n      hidden\n    } = this;\n    var hiddenValue = options.hiddenValue;\n    if (hidden === true) {\n      return hiddenValue !== undefined ? {\n        xs: hiddenValue\n      } : {};\n    }\n    var candidate;\n    return createSxResult((bp, lastResultVal) => {\n      var _config$bp;\n      candidate = (_config$bp = config[bp]) !== null && _config$bp !== void 0 ? _config$bp : candidate;\n      if (options.strict && lastResultVal === undefined && candidate === undefined) {\n        // cannot find valid config and no result yet\n        return hiddenValue;\n      }\n      if (candidate !== undefined) {\n        var assignedValue = options.assignValue(candidate, bp, lastResultVal);\n        var isHidden = Array.isArray(hidden) && hidden.includes(bp);\n        return isHidden ? hiddenValue : assignedValue;\n      }\n      return undefined;\n    });\n  }\n  generateSx(getValue, initialValue) {\n    return createSxResult(bp => getValue(this.config[bp], bp), {\n      breakpoints: this.breakpointKeys,\n      initialValue\n    });\n  }\n  getSxDisplay(appearance) {\n    return this.generateSxWithHidden({\n      assignValue: () => appearance,\n      hiddenValue: \"none\",\n      strict: true\n    });\n  }\n}","map":{"version":3,"names":["createSxResult","BREAKPOINT_KEYS","ResponsiveBuilder","constructor","params","config","hidden","breakpointKeys","Object","keys","isHidden","breakpoint","includes","mergeBreakpoints","target","targetFound","result","targetKeys","Array","isArray","thisKeys","forEach","key","push","generateSxWithHidden","options","hiddenValue","undefined","xs","candidate","bp","lastResultVal","_config$bp","strict","assignedValue","assignValue","generateSx","getValue","initialValue","breakpoints","getSxDisplay","appearance"],"sources":["/Users/rezaaditya/Documents/github/mui-app-v3/node_modules/@mui-treasury/layout/esm/shared/ResponsiveBuilder.js"],"sourcesContent":["import { createSxResult } from \"../utils/createSxResult\";\nimport { BREAKPOINT_KEYS } from \"../utils/muiBreakpoints\";\nexport class ResponsiveBuilder {\n  constructor(params) {\n    this.config = params.config;\n    this.hidden = params.hidden;\n    this.breakpointKeys = Object.keys(params.config);\n  }\n\n  isHidden(breakpoint) {\n    if (!this.hidden) return false;\n    if (typeof this.hidden === \"boolean\" && this.hidden) return true;\n    return this.hidden.includes(breakpoint);\n  }\n  /**\n   * use target as base breakpoints, the result will start from the minimum of target\n   *          xs | sm | md | lg | xl\n   *  target     | y  |    |  y |\n   *   this   y  |    | y  |    |\n   *  ===============================\n   *  result     | y  | y  | y  |\n   */\n\n\n  mergeBreakpoints(target) {\n    var targetFound = false;\n    var result = [];\n    var targetKeys = Array.isArray(target) ? target : Object.keys(target);\n    var thisKeys = Object.keys(this.config);\n    BREAKPOINT_KEYS.forEach(key => {\n      if (targetKeys.includes(key)) {\n        targetFound = true;\n        result.push(key);\n      } else {\n        if (thisKeys.includes(key) && targetFound) {\n          result.push(key);\n        }\n      }\n    });\n    return result;\n  }\n\n  generateSxWithHidden(options) {\n    var {\n      config,\n      hidden\n    } = this;\n    var hiddenValue = options.hiddenValue;\n\n    if (hidden === true) {\n      return hiddenValue !== undefined ? {\n        xs: hiddenValue\n      } : {};\n    }\n\n    var candidate;\n    return createSxResult((bp, lastResultVal) => {\n      var _config$bp;\n\n      candidate = (_config$bp = config[bp]) !== null && _config$bp !== void 0 ? _config$bp : candidate;\n\n      if (options.strict && lastResultVal === undefined && candidate === undefined) {\n        // cannot find valid config and no result yet\n        return hiddenValue;\n      }\n\n      if (candidate !== undefined) {\n        var assignedValue = options.assignValue(candidate, bp, lastResultVal);\n        var isHidden = Array.isArray(hidden) && hidden.includes(bp);\n        return isHidden ? hiddenValue : assignedValue;\n      }\n\n      return undefined;\n    });\n  }\n\n  generateSx(getValue, initialValue) {\n    return createSxResult(bp => getValue(this.config[bp], bp), {\n      breakpoints: this.breakpointKeys,\n      initialValue\n    });\n  }\n\n  getSxDisplay(appearance) {\n    return this.generateSxWithHidden({\n      assignValue: () => appearance,\n      hiddenValue: \"none\",\n      strict: true\n    });\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}