{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rezaaditya/Documents/github/mui-react-redux-boilerplate-v3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { BREAKPOINT_KEYS } from \"../utils/muiBreakpoints\";\nimport { pickNearestBreakpoint } from \"../utils/pickNearestBreakpoint\";\nimport { StackedHeaders } from \"./StackedHeaders\";\nexport var HeadersCompiler = function HeadersCompiler(headers) {\n  var validHeaders = headers.filter(function (h) {\n    return !!h;\n  });\n  function getResult(modifyConfigAtBreakpoint) {\n    var result = {\n      totalHeight: {},\n      diffHeight: {}\n    };\n    var prevHidden = Array(validHeaders.length).fill(false); // keep track of hidden in previous breakpoint\n\n    var _loop = function _loop(_bp) {\n      var configs = [];\n      var shouldCalculate = false;\n      shouldCalculate = prevHidden.some(function (bool) {\n        return !!bool;\n      });\n      validHeaders.forEach(function (builder) {\n        if (builder.config[_bp]) {\n          shouldCalculate = true;\n        }\n      });\n      if (shouldCalculate) {\n        validHeaders.forEach(function (builder, index) {\n          var breakpointConfig = pickNearestBreakpoint(builder.config, _bp);\n          if (builder.isHidden(_bp)) {\n            prevHidden[index] = true;\n            if (breakpointConfig) {\n              configs.push(_objectSpread(_objectSpread({}, breakpointConfig), {}, {\n                height: 0\n              }));\n            }\n          } else {\n            if (prevHidden[index]) {\n              prevHidden[index] = false;\n            }\n            if (breakpointConfig) {\n              configs.push(modifyConfigAtBreakpoint ? modifyConfigAtBreakpoint(_bp, builder, breakpointConfig) : breakpointConfig);\n            }\n          }\n        });\n      }\n      if (configs.length) {\n        var _StackedHeaders = StackedHeaders(configs),\n          totalHeight = _StackedHeaders.totalHeight,\n          diffHeight = _StackedHeaders.diffHeight;\n        if (pickNearestBreakpoint(result.totalHeight, _bp) !== totalHeight) {\n          result.totalHeight[_bp] = totalHeight;\n        }\n        if (pickNearestBreakpoint(result.diffHeight, _bp) !== diffHeight) {\n          result.diffHeight[_bp] = diffHeight;\n        }\n      }\n    };\n    var _iterator = _createForOfIteratorHelper(BREAKPOINT_KEYS),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _bp = _step.value;\n        _loop(_bp);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  }\n  return {\n    getClippedHeight: function getClippedHeight(sidebarId) {\n      // for EdgeSidebarOffset\n      return getResult(function (bp, builder, config) {\n        return _objectSpread(_objectSpread({}, config), !builder.isClipped(sidebarId, bp) && {\n          height: 0\n        });\n      });\n    },\n    getAllHeight: function getAllHeight() {\n      // for InsetSidebarOffset\n      return getResult();\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}