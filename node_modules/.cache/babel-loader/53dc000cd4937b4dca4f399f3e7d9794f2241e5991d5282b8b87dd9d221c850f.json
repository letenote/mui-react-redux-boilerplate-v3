{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rezaaditya/Documents/github/mui-app-v3/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { BREAKPOINT_KEYS } from \"./muiBreakpoints\";\nexport var pickNearestBreakpoint = function pickNearestBreakpoint(value, currentBreakpoint) {\n  if (!value || !currentBreakpoint) return undefined;\n  var breakpointIndex = BREAKPOINT_KEYS.indexOf(currentBreakpoint);\n  if (breakpointIndex === -1) {\n    throw new Error(\"Breakpoint: \\\"\".concat(currentBreakpoint, \"\\\" does not exist in [\").concat(BREAKPOINT_KEYS.join(\",\"), \"]\"));\n  } // [breakpoint, ..., 'xs']\n\n  var possibleBreakpoints = BREAKPOINT_KEYS.slice(0, BREAKPOINT_KEYS.indexOf(currentBreakpoint) + 1).reverse();\n  var result = value[currentBreakpoint];\n  if (result) return result; // return the first valid value\n  var _iterator = _createForOfIteratorHelper(possibleBreakpoints),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var bp = _step.value;\n      if (result !== undefined) return result;\n      result = value[bp];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n};","map":{"version":3,"names":["BREAKPOINT_KEYS","pickNearestBreakpoint","value","currentBreakpoint","undefined","breakpointIndex","indexOf","Error","concat","join","possibleBreakpoints","slice","reverse","result","bp"],"sources":["/Users/rezaaditya/Documents/github/mui-app-v3/node_modules/@mui-treasury/layout/esm/utils/pickNearestBreakpoint.js"],"sourcesContent":["import { BREAKPOINT_KEYS } from \"./muiBreakpoints\";\nexport var pickNearestBreakpoint = (value, currentBreakpoint) => {\n  if (!value || !currentBreakpoint) return undefined;\n  var breakpointIndex = BREAKPOINT_KEYS.indexOf(currentBreakpoint);\n\n  if (breakpointIndex === -1) {\n    throw new Error(\"Breakpoint: \\\"\".concat(currentBreakpoint, \"\\\" does not exist in [\").concat(BREAKPOINT_KEYS.join(\",\"), \"]\"));\n  } // [breakpoint, ..., 'xs']\n\n\n  var possibleBreakpoints = BREAKPOINT_KEYS.slice(0, BREAKPOINT_KEYS.indexOf(currentBreakpoint) + 1).reverse();\n  var result = value[currentBreakpoint];\n  if (result) return result; // return the first valid value\n\n  for (var bp of possibleBreakpoints) {\n    if (result !== undefined) return result;\n    result = value[bp];\n  }\n\n  return result;\n};"],"mappings":";AAAA,SAASA,eAAe,QAAQ,kBAAkB;AAClD,OAAO,IAAIC,qBAAqB,GAAG,SAAxBA,qBAAqB,CAAIC,KAAK,EAAEC,iBAAiB,EAAK;EAC/D,IAAI,CAACD,KAAK,IAAI,CAACC,iBAAiB,EAAE,OAAOC,SAAS;EAClD,IAAIC,eAAe,GAAGL,eAAe,CAACM,OAAO,CAACH,iBAAiB,CAAC;EAEhE,IAAIE,eAAe,KAAK,CAAC,CAAC,EAAE;IAC1B,MAAM,IAAIE,KAAK,CAAC,gBAAgB,CAACC,MAAM,CAACL,iBAAiB,EAAE,wBAAwB,CAAC,CAACK,MAAM,CAACR,eAAe,CAACS,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;EAC9H,CAAC,CAAC;;EAGF,IAAIC,mBAAmB,GAAGV,eAAe,CAACW,KAAK,CAAC,CAAC,EAAEX,eAAe,CAACM,OAAO,CAACH,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAACS,OAAO,EAAE;EAC5G,IAAIC,MAAM,GAAGX,KAAK,CAACC,iBAAiB,CAAC;EACrC,IAAIU,MAAM,EAAE,OAAOA,MAAM,CAAC,CAAC;EAAA,2CAEZH,mBAAmB;IAAA;EAAA;IAAlC,oDAAoC;MAAA,IAA3BI,EAAE;MACT,IAAID,MAAM,KAAKT,SAAS,EAAE,OAAOS,MAAM;MACvCA,MAAM,GAAGX,KAAK,CAACY,EAAE,CAAC;IACpB;EAAC;IAAA;EAAA;IAAA;EAAA;EAED,OAAOD,MAAM;AACf,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}