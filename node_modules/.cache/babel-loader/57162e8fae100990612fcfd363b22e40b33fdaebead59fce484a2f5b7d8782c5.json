{"ast":null,"code":"import { createSxResult } from \"../utils/createSxResult\";\nimport { BREAKPOINT_KEYS } from \"../utils/muiBreakpoints\";\nexport class ResponsiveBuilder {\n  constructor(params) {\n    this.config = params.config;\n    this.hidden = params.hidden;\n    this.breakpointKeys = Object.keys(params.config);\n  }\n  isHidden(breakpoint) {\n    if (!this.hidden) return false;\n    if (typeof this.hidden === \"boolean\" && this.hidden) return true;\n    return this.hidden.includes(breakpoint);\n  }\n  /**\n   * use target as base breakpoints, the result will start from the minimum of target\n   *          xs | sm | md | lg | xl\n   *  target     | y  |    |  y |\n   *   this   y  |    | y  |    |\n   *  ===============================\n   *  result     | y  | y  | y  |\n   */\n\n  mergeBreakpoints(target) {\n    var targetFound = false;\n    var result = [];\n    var targetKeys = Array.isArray(target) ? target : Object.keys(target);\n    var thisKeys = Object.keys(this.config);\n    BREAKPOINT_KEYS.forEach(key => {\n      if (targetKeys.includes(key)) {\n        targetFound = true;\n        result.push(key);\n      } else {\n        if (thisKeys.includes(key) && targetFound) {\n          result.push(key);\n        }\n      }\n    });\n    return result;\n  }\n  generateSxWithHidden(options) {\n    var {\n      config,\n      hidden\n    } = this;\n    var hiddenValue = options.hiddenValue;\n    if (hidden === true) {\n      return hiddenValue !== undefined ? {\n        xs: hiddenValue\n      } : {};\n    }\n    var candidate;\n    return createSxResult((bp, lastResultVal) => {\n      var _config$bp;\n      candidate = (_config$bp = config[bp]) !== null && _config$bp !== void 0 ? _config$bp : candidate;\n      if (options.strict && lastResultVal === undefined && candidate === undefined) {\n        // cannot find valid config and no result yet\n        return hiddenValue;\n      }\n      if (candidate !== undefined) {\n        var assignedValue = options.assignValue(candidate, bp, lastResultVal);\n        var isHidden = Array.isArray(hidden) && hidden.includes(bp);\n        return isHidden ? hiddenValue : assignedValue;\n      }\n      return undefined;\n    });\n  }\n  generateSx(getValue, initialValue) {\n    return createSxResult(bp => getValue(this.config[bp], bp), {\n      breakpoints: this.breakpointKeys,\n      initialValue\n    });\n  }\n  getSxDisplay(appearance) {\n    return this.generateSxWithHidden({\n      assignValue: () => appearance,\n      hiddenValue: \"none\",\n      strict: true\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}